## 目录 ##
* [引言](0.Introduction/0.md)
 - 0.1 [入门]
 - 0.2 [什么是计算机科学？]
 - 0.3 [什么是编程？]
 - 0.4 [为什么要学习数据结构和抽象数据类型？]
 - 0.5 [为什么要学习算法？]
 - 0.6 [基础 Python 知识回顾]
 - 0.7 [从数据入手]
    - 0.7.1 [内部的基本数据结构]
	- 0.7.2 [内部的集合数据结构]
 - 0.8 [输入与输出]	
	  - 0.8.1 [字符串格式化]
 - 0.9 [控制结构]
 - 0.10 [异常处理]
 - 0.11 [定义函数]
 - 0.12 [Python 面向对象程序设计：定义类]
 	  - 0.12.1 [Fraction 类（分数）]
  	- 0.12.2 [继承：逻辑门和逻辑闭环]
    - 0.13 [小结]
 
* 1 [分析](1.Analysis/1.md)
 - 1.1 [什么是算法分析？]
 - 1.2 [大O符号]
 - 1.3 [检查易位构词游戏的例子]
    - 1.3.1 [解法1：逐项校对]
    - 1.3.2 [解法2：排序比较]
    - 1.3.3 [解法3：强力检索]
    - 1.3.3 [解法4：计数对比]
 - 1.4 [Python 数据结构的性能]
 - 1.5 [列表]
 - 1.6 [字典]
 - 1.7 [小结]
  	 
* 2 [基本数据结构](2.Basic_Data_Structures/2.md)
 - 2.1 [什么是线性结构？]
 - 2.2 [什么是堆栈？]
 - 2.3 [关于堆栈]
 - 2.4 [在 Python 中实现堆栈]
 - 2.5 [简单的对称括号]
 - 2.6 [对称符号（一个普适例子）]
 - 2.7 [十进制转化为二进制]
 - 2.8 [中缀、前缀和后缀的表达式]
    - 2.8.1 [中缀表达式向前缀和后缀的转化]
    - 2.8.2 [中缀表达式向后缀转化的一般原则]
    - 2.8.3 [后缀的变形]
 - 2.9 [什么是队列？]
 - 2.10 [关于队列]
 - 2.11 [在 Python 中实现队列]
 - 2.12 [模拟：Hot Potato]
 - 2.13 [模拟：打印任务]
    - 2.13.1 [主模拟步骤]
    - 2.13.2 [用 Python 实现]
    - 2.13.3 [相关讨论]
 - 2.14 [什么是双端队列？]
 - 2.15 [关于双端队列]
 - 2.16 [在 Python 中实现双端队列]
 - 2.17 [回文校验器]
 - 2.18 [列表]
 - 2.19 [关于无序列表]
 - 2.20 [无序列表的实现：链表]
    - 2.20.1 [Node 类（节点）]
    - 2.20.2 [Unordered List 类（无序列表）]
 - 2.21 [关于有序列表]
 - 2.22 [有序列表的实现]
    - 2.22.1 [链表分析]
 - 2.23 [小结]
 
* 3 [递归](3.Recursion/3.md)
 - 3.1 [什么是递归？]
 - 3.2 [计算数表的和]
 - 3.3 [递归的三个法则]
 - 3.4 [任意底数下整数向字符串的转化]
 - 3.5 [堆栈框架：实现递归]
 - 3.6 [谢尔宾斯基三角形问题] 
 - 3.7 [复杂的递归问题] 
 - 3.8 [汉诺塔问题]
 - 3.9 [迷宫探索问题]
 - 3.10 [动态编程]
 - 3.11 [小结]
  
* 4 [排序与搜索](4.Sorting_and_Searching/4.md)
 - 4.1 [搜索]
 - 4.2 [线性搜索]
    - 4.2.1 [关于线性搜索] 
 - 4.3 [二分搜索]
    - 4.3.1 [关于二分搜索]  
 - 4.4 [散列]
    - 4.4.1 [散列函数]
    - 4.4.2 [碰撞处理] 
    - 4.4.3 [实现 Map 抽象数据类型（地图）] 
    - 4.4.4 [关于散列]              
 - 4.5 [排序]
 - 4.6 [冒泡排序]
 - 4.7 [选择排序]
 - 4.8 [插入排序]
 - 4.9 [希尔排序]
 - 4.10 [归并排序]
 - 4.11 [快速排序]
 - 4.12 [小结] 
     
* 5 [树和树算法](5.Trees_and_Tree_Algorithms/5.md)
 - 5.1 [树的例子]
 - 5.2 [术语和定义]
 - 5.3 [用列表体现]
 - 5.4 [节点和标记]
 - 5.5 [分析树]
 - 5.6 [树的遍历]
 - 5.7 [用二叉堆体现优先队列]
 - 5.8 [二叉堆运算]
 - 5.9 [实现二叉堆]
    - 5.9.1 [结构属性]
    - 5.9.2 [堆的顺序属性]
    - 5.9.3 [堆的运算]    
 - 5.10 [二叉搜索树]
 - 5.11 [搜索树的运算]
 - 5.12 [实现搜索树]
 - 5.13 [关于搜索树]
 - 5.14 [平衡树]         
 - 5.15 [AVL 树性能]
 - 5.16 [实现 AVL 树]
 - 5.17 [Map ADT（地图）的实现总结]
 - 5.18 [小结]
     
* 6 [图和图算法](6.Graphs_and_Graph_Algorithms/6.md)
 - 6.1 [术语和定义]
 - 6.2 [Graph 抽象数据类型（图）]
 - 6.3 [邻接矩阵]
 - 6.4 [邻接列表]
 - 6.5 [相关实现]
 - 6.6 [词梯游戏问题]
 - 6.7 [构造词梯图]
 - 6.8 [实现广度优先搜索]
 - 6.9 [关于广度优先搜索]
 - 6.10 [骑士巡逻问题]
 - 6.11 [构造骑士巡逻图]
 - 6.12 [实现骑士巡逻]
 - 6.13 [关于骑士巡逻问题]
 - 6.14 [一般的深度优先搜索]
 - 6.15 [关于深度优先搜索]
 - 6.16 [拓扑排序]
 - 6.17 [强连通分量] 
 - 6.18 [最短路问题]
 - 6.19 [戴克斯特拉算法]
 - 6.20 [关于戴克斯特拉算法]
 - 6.21 [普里姆最小生成树算法]  
 - 6.22 [小结]
 
* [引用文献]